{"ast":null,"code":"import KDBush from 'kdbush';\nconst defaultOptions = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  minPoints: 2,\n  // minimum points to form a cluster\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n  // whether to generate numeric ids for input features (in vector tiles)\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n  // properties to use for individual points when running the reducer\n  map: props => props // props => ({sum: props.my_value})\n\n};\n\nconst fround = Math.fround || (tmp => x => {\n  tmp[0] = +x;\n  return tmp[0];\n})(new Float32Array(1));\n\nexport default class Supercluster {\n  constructor(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  }\n\n  load(points) {\n    const {\n      log,\n      minZoom,\n      maxZoom,\n      nodeSize\n    } = this.options;\n    if (log) console.time('total time');\n    const timerId = `prepare ${points.length} points`;\n    if (log) console.time(timerId);\n    this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n    let clusters = [];\n\n    for (let i = 0; i < points.length; i++) {\n      if (!points[i].geometry) continue;\n      clusters.push(createPointCluster(points[i], i));\n    }\n\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n    if (log) console.timeEnd(timerId); // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n\n    for (let z = maxZoom; z >= minZoom; z--) {\n      const now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n      if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n    }\n\n    if (log) console.timeEnd('total time');\n    return this;\n  }\n\n  getClusters(bbox, zoom) {\n    let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    const minLat = Math.max(-90, Math.min(90, bbox[1]));\n    let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n\n    const tree = this.trees[this._limitZoom(zoom)];\n\n    const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    const clusters = [];\n\n    for (const id of ids) {\n      const c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n\n    return clusters;\n  }\n\n  getChildren(clusterId) {\n    const originId = this._getOriginId(clusterId);\n\n    const originZoom = this._getOriginZoom(clusterId);\n\n    const errorMsg = 'No cluster with the specified id.';\n    const index = this.trees[originZoom];\n    if (!index) throw new Error(errorMsg);\n    const origin = index.points[originId];\n    if (!origin) throw new Error(errorMsg);\n    const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    const ids = index.within(origin.x, origin.y, r);\n    const children = [];\n\n    for (const id of ids) {\n      const c = index.points[id];\n\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n\n    if (children.length === 0) throw new Error(errorMsg);\n    return children;\n  }\n\n  getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    const leaves = [];\n\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n  }\n\n  getTile(z, x, y) {\n    const tree = this.trees[this._limitZoom(z)];\n\n    const z2 = Math.pow(2, z);\n    const {\n      extent,\n      radius\n    } = this.options;\n    const p = radius / extent;\n    const top = (y - p) / z2;\n    const bottom = (y + 1 + p) / z2;\n    const tile = {\n      features: []\n    };\n\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n  }\n\n  getClusterExpansionZoom(clusterId) {\n    let expansionZoom = this._getOriginZoom(clusterId) - 1;\n\n    while (expansionZoom <= this.options.maxZoom) {\n      const children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) break;\n      clusterId = children[0].properties.cluster_id;\n    }\n\n    return expansionZoom;\n  }\n\n  _appendLeaves(result, clusterId, limit, offset, skipped) {\n    const children = this.getChildren(clusterId);\n\n    for (const child of children) {\n      const props = child.properties;\n\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n\n      if (result.length === limit) break;\n    }\n\n    return skipped;\n  }\n\n  _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (const i of ids) {\n      const c = points[i];\n      const isCluster = c.numPoints;\n      let tags, px, py;\n\n      if (isCluster) {\n        tags = getClusterProperties(c);\n        px = c.x;\n        py = c.y;\n      } else {\n        const p = this.points[c.index];\n        tags = p.properties;\n        px = lngX(p.geometry.coordinates[0]);\n        py = latY(p.geometry.coordinates[1]);\n      }\n\n      const f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags\n      }; // assign id\n\n      let id;\n\n      if (isCluster) {\n        id = c.id;\n      } else if (this.options.generateId) {\n        // optionally generate id\n        id = c.index;\n      } else if (this.points[c.index].id) {\n        // keep id if already assigned\n        id = this.points[c.index].id;\n      }\n\n      if (id !== undefined) f.id = id;\n      tile.features.push(f);\n    }\n  }\n\n  _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n  }\n\n  _cluster(points, zoom) {\n    const clusters = [];\n    const {\n      radius,\n      extent,\n      reduce,\n      minPoints\n    } = this.options;\n    const r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n    for (let i = 0; i < points.length; i++) {\n      const p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n      if (p.zoom <= zoom) continue;\n      p.zoom = zoom; // find all nearby points\n\n      const tree = this.trees[zoom + 1];\n      const neighborIds = tree.within(p.x, p.y, r);\n      const numPointsOrigin = p.numPoints || 1;\n      let numPoints = numPointsOrigin; // count the number of points in a potential cluster\n\n      for (const neighborId of neighborIds) {\n        const b = tree.points[neighborId]; // filter out neighbors that are already processed\n\n        if (b.zoom > zoom) numPoints += b.numPoints || 1;\n      } // if there were neighbors to merge, and there are enough points to form a cluster\n\n\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        let wx = p.x * numPointsOrigin;\n        let wy = p.y * numPointsOrigin;\n        let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features\n\n        const id = (i << 5) + (zoom + 1) + this.points.length;\n\n        for (const neighborId of neighborIds) {\n          const b = tree.points[neighborId];\n          if (b.zoom <= zoom) continue;\n          b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n          const numPoints2 = b.numPoints || 1;\n          wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n          wy += b.y * numPoints2;\n          b.parentId = id;\n\n          if (reduce) {\n            if (!clusterProperties) clusterProperties = this._map(p, true);\n            reduce(clusterProperties, this._map(b));\n          }\n        }\n\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      } else {\n        // left points as unclustered\n        clusters.push(p);\n\n        if (numPoints > 1) {\n          for (const neighborId of neighborIds) {\n            const b = tree.points[neighborId];\n            if (b.zoom <= zoom) continue;\n            b.zoom = zoom;\n            clusters.push(b);\n          }\n        }\n      }\n    }\n\n    return clusters;\n  } // get index of the point from which the cluster originated\n\n\n  _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  } // get zoom of the point from which the cluster originated\n\n\n  _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  }\n\n  _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n\n    const original = this.points[point.index].properties;\n    const result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  }\n\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n  return {\n    x: fround(x),\n    // weighted cluster center; round for consistency with Float32Array index\n    y: fround(y),\n    zoom: Infinity,\n    // the last zoom the cluster was processed at\n    id,\n    // encodes index of the first child of the cluster and its zoom level\n    parentId: -1,\n    // parent cluster id\n    numPoints,\n    properties\n  };\n}\n\nfunction createPointCluster(p, id) {\n  const [x, y] = p.geometry.coordinates;\n  return {\n    x: fround(lngX(x)),\n    // projected point coordinates\n    y: fround(latY(y)),\n    zoom: Infinity,\n    // the last zoom the point was processed at\n    index: id,\n    // index of the source feature in the original input array,\n    parentId: -1 // parent cluster id\n\n  };\n}\n\nfunction getClusterJSON(cluster) {\n  return {\n    type: 'Feature',\n    id: cluster.id,\n    properties: getClusterProperties(cluster),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(cluster.x), yLat(cluster.y)]\n    }\n  };\n}\n\nfunction getClusterProperties(cluster) {\n  const count = cluster.numPoints;\n  const abbrev = count >= 10000 ? `${Math.round(count / 1000)}k` : count >= 1000 ? `${Math.round(count / 100) / 10}k` : count;\n  return extend(extend({}, cluster.properties), {\n    cluster: true,\n    cluster_id: cluster.id,\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n} // longitude/latitude to spherical mercator in [0..1] range\n\n\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\n\nfunction latY(lat) {\n  const sin = Math.sin(lat * Math.PI / 180);\n  const y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n} // spherical mercator to longitude/latitude\n\n\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\n\nfunction yLat(y) {\n  const y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n  for (const id in src) dest[id] = src[id];\n\n  return dest;\n}\n\nfunction getX(p) {\n  return p.x;\n}\n\nfunction getY(p) {\n  return p.y;\n}","map":{"version":3,"names":["KDBush","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","nodeSize","log","generateId","reduce","map","props","fround","Math","tmp","x","Float32Array","Supercluster","constructor","options","extend","Object","create","trees","Array","load","points","console","time","timerId","length","clusters","i","geometry","push","createPointCluster","getX","getY","timeEnd","z","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","max","min","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","ids","range","lngX","latY","id","c","numPoints","getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","r","pow","within","y","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","p","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","result","skipped","child","cluster","point_count","isCluster","tags","px","py","getClusterProperties","coordinates","f","type","round","undefined","floor","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","numPoints2","createCluster","point","clone","original","Infinity","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","exp","dest","src"],"sources":["/Users/chineduetoh/Desktop/IONIC PROJECTS/Go_Rider/node_modules/supercluster/index.js"],"sourcesContent":["\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}